"""refactor messages to new table

Revision ID: d05a6eb85983
Revises: 7d5878ee6550
Create Date: 2025-10-21 11:19:51.759035

"""
import json
from typing import Sequence, Union

from alembic import op
import sqlalchemy as sa


# revision identifiers, used by Alembic.
revision: str = 'd05a6eb85983'
down_revision: Union[str, None] = '294446b276e4'
branch_labels: Union[str, Sequence[str], None] = None
depends_on: Union[str, Sequence[str], None] = None


def upgrade() -> None:
    # ### commands auto generated by Alembic - please adjust! ###
    op.create_table('transcript_messages',
    sa.Column('id', sa.UUID(), nullable=False),
    sa.Column('conversation_id', sa.UUID(), nullable=False),
    sa.Column('create_time', sa.DateTime(timezone=True), nullable=False),
    sa.Column('start_time', sa.Float(), nullable=False),
    sa.Column('end_time', sa.Float(), nullable=False),
    sa.Column('speaker', sa.String(length=50), nullable=False),
    sa.Column('text', sa.Text(), nullable=False),
    sa.Column('type', sa.String(length=50), nullable=False),
    sa.Column('sequence_number', sa.Integer(), nullable=False),
    sa.Column('created_by', sa.UUID(), nullable=True),
    sa.Column('updated_by', sa.UUID(), nullable=True),
    sa.Column('created_at', sa.DateTime(timezone=True), server_default=sa.text('CURRENT_TIMESTAMP'), nullable=True),
    sa.Column('updated_at', sa.DateTime(timezone=True), server_default=sa.text('CURRENT_TIMESTAMP'), nullable=True),
    sa.Column('is_deleted', sa.Integer(), nullable=False),
    sa.ForeignKeyConstraint(['conversation_id'], ['conversations.id'], ondelete='CASCADE'),
    sa.PrimaryKeyConstraint('id')
    )
    op.create_index(op.f('ix_transcript_messages_conversation_id'), 'transcript_messages', ['conversation_id'], unique=False)
    op.create_index(op.f('ix_transcript_messages_id'), 'transcript_messages', ['id'], unique=True)
    op.create_table('message_feedback',
    sa.Column('id', sa.UUID(), nullable=False),
    sa.Column('message_id', sa.UUID(), nullable=False),
    sa.Column('feedback', sa.String(length=50), nullable=False),
    sa.Column('feedback_timestamp', sa.DateTime(timezone=True), nullable=False),
    sa.Column('feedback_user_id', sa.UUID(), nullable=False),
    sa.Column('feedback_message', sa.Text(), nullable=True),
    sa.Column('created_by', sa.UUID(), nullable=True),
    sa.Column('updated_by', sa.UUID(), nullable=True),
    sa.Column('created_at', sa.DateTime(timezone=True), server_default=sa.text('CURRENT_TIMESTAMP'), nullable=True),
    sa.Column('updated_at', sa.DateTime(timezone=True), server_default=sa.text('CURRENT_TIMESTAMP'), nullable=True),
    sa.Column('is_deleted', sa.Integer(), nullable=False),
    sa.ForeignKeyConstraint(['message_id'], ['transcript_messages.id'], ondelete='CASCADE'),
    sa.PrimaryKeyConstraint('id')
    )
    op.create_index(op.f('ix_message_feedback_message_id'), 'message_feedback', ['message_id'], unique=False)
    op.create_unique_constraint(None, 'webhooks', ['id'])

    # Migrate data from transcription JSON to new tables
    print("Starting data migration...")
    migrate_transcript_data()

    print("Migration completed successfully!")


def downgrade() -> None:
    # Restore data back to transcription field
    restore_transcript_data()
    op.drop_index(op.f('ix_message_feedback_message_id'), table_name='message_feedback')
    op.drop_table('message_feedback')
    op.drop_index(op.f('ix_transcript_messages_id'), table_name='transcript_messages')
    op.drop_index(op.f('ix_transcript_messages_conversation_id'), table_name='transcript_messages')
    op.drop_table('transcript_messages')


def migrate_transcript_data():
    """Migrate existing transcript JSON data to new tables"""
    from sqlalchemy import text
    from uuid import uuid4

    connection = op.get_bind()

    # Get all conversations with transcripts
    conversations = connection.execute(
            text("SELECT id, transcription FROM conversations WHERE transcription IS NOT NULL")
            ).fetchall()

    total = len(conversations)
    print(f"Migrating {total} conversations...")

    for idx, (conversation_id, transcription) in enumerate(conversations):
        if idx % 100 == 0:
            print(f"Progress: {idx}/{total}")

        try:
            transcript_data = json.loads(transcription)
        except json.JSONDecodeError:
            print(f"Warning: Could not parse transcript for conversation {conversation_id}")
            continue

        # Insert messages
        for seq_num, segment in enumerate(transcript_data):
            try:
                # Generate UUID for the new message row
                new_message_id = uuid4()

                # Insert message
                result = connection.execute(
                        text("""
                             INSERT INTO transcript_messages
                             (id, conversation_id, create_time, start_time, end_time,
                              speaker, text, type, sequence_number, is_deleted)
                             VALUES (:id, :conv_id, :create_time, :start_time, :end_time,
                                     :speaker, :text, :type, :seq_num, :is_deleted) RETURNING id
                             """),
                        {
                            'id': new_message_id,
                            'conv_id': conversation_id,
                            'create_time': segment['create_time'],
                            'start_time': segment.get('start_time', 0),
                            'end_time': segment.get('end_time', 0),
                            'speaker': segment.get('speaker', ''),
                            'text': segment.get('text', ''),
                            'type': segment.get('type', 'message'),
                            'seq_num': seq_num,
                            'is_deleted': segment.get('is_deleted', 0)
                            }
                        )

                message_pk = result.fetchone()[0]

                # Insert feedback if exists
                feedback_list = segment.get('feedback', [])
                if feedback_list:
                    for feedback_item in feedback_list:
                        feedback_id = uuid4()
                        connection.execute(
                                text("""
                                     INSERT INTO message_feedback
                                     (id, message_id, feedback, feedback_timestamp,
                                      feedback_user_id, feedback_message, is_deleted)
                                     VALUES (:id, :msg_id, :feedback, :timestamp, :user_id, :message, :is_deleted)
                                     """),
                                {
                                    'id': feedback_id,
                                    'msg_id': message_pk,
                                    'feedback': feedback_item['feedback'],
                                    'timestamp': feedback_item['feedback_timestamp'],
                                    'user_id': feedback_item['feedback_user_id'],
                                    'message': feedback_item.get('feedback_message'),
                                    'is_deleted': feedback_item.get('is_deleted', 0)
                                    }
                                )

            except Exception as e:
                print(f"Error migrating segment for conversation {conversation_id}: {e}")
                continue

    print(f"Migration completed: {total} conversations processed")


def restore_transcript_data():
    """Restore transcript data back to JSON format for rollback"""
    from sqlalchemy import text

    connection = op.get_bind()

    # Get all conversations
    conversations = connection.execute(
            text("SELECT DISTINCT conversation_id FROM transcript_messages")
            ).fetchall()

    print(f"Restoring {len(conversations)} conversations...")

    for (conversation_id,) in conversations:
        # Get messages with feedback - join uses UUID ids now
        messages = connection.execute(
                text("""
                     SELECT tm.id,
                            tm.create_time,
                            tm.start_time,
                            tm.end_time,
                            tm.speaker,
                            tm.text,
                            tm.type,
                            tm.sequence_number,
                            mf.feedback,
                            mf.feedback_timestamp,
                            mf.feedback_user_id,
                            mf.feedback_message
                     FROM transcript_messages tm
                              LEFT JOIN message_feedback mf ON mf.message_id = tm.id
                     WHERE tm.conversation_id = :conv_id
                     ORDER BY tm.sequence_number
                     """),
                {'conv_id': conversation_id}
                ).fetchall()

        # Build transcript structure
        transcript_dict = {}
        for row in messages:
            msg_id = str(row[0])
            if msg_id not in transcript_dict:
                transcript_dict[msg_id] = {
                    'message_id': msg_id,
                    'create_time': row[1].isoformat(),
                    'start_time': row[2],
                    'end_time': row[3],
                    'speaker': row[4],
                    'text': row[5],
                    'type': row[6],
                    'feedback': []
                    }

            # Add feedback if present
            if row[8]:  # feedback field
                transcript_dict[msg_id]['feedback'].append({
                    'feedback': row[8],
                    'feedback_timestamp': row[9].isoformat(),
                    'feedback_user_id': str(row[10]),
                    'feedback_message': row[11]
                    })

        # Convert to list and sort by sequence
        transcript_list = list(transcript_dict.values())
        transcript_json = json.dumps(transcript_list, ensure_ascii=False)

        # Update conversation
        connection.execute(
                text("UPDATE conversations SET transcription = :transcript WHERE id = :conv_id"),
                {'transcript': transcript_json, 'conv_id': conversation_id}
                )

    print("Restore completed!")